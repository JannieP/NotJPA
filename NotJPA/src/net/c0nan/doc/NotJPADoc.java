package net.c0nan.doc;

public class NotJPADoc {

	/**
	 * Project NotJPAExtended - contains extended template classes
	 * ---------------------------------
	 * public class SharedDBDTO extends DBDTO implements Serializable
	 * public class PagingDTO implements Serializable,Cloneable
	 * public class SharedDTO extends PagingDTO implements Serializable,Cloneable
	 * public interface SharedInterface<A extends SharedDTO>
	 * public abstract class SharedBean<A extends SharedDTO,B extends SharedDBDTO> implements SharedServiceInterface<A>
	 * ---------------------------------
	 * 
	 * How to Use NotJPA Framework
	 * 
	 * E.g: on DBMS is SC1.TABLE1 (ID BIGINT AUTOGEN PK, AVALUE CHAR(10),NVALUE BIGINT,AUDITIME TIMESTAMP)
	 * 
	 * Create a DBDTO class in your EJB project, include named Queries if you want
	 * 
@NamedQueries(
		Queries={
		@NamedQuery(Name="query1", Query="select * from SC1.TABLE1 where AVALUE = ':AV1' and NVALUE=:NV1 "),
		@NamedQuery(Name="query2", Query="select count(*) as CNT from SC1.TABLE1 where AVALUE = ':AV1' and NVALUE=:NV1"),
		})
@Bindable(Table = "TABLE1",Schema="SC1", DBMS = Bindable.DBMS.DB02)
public class table1DBDTO  extends SharedDBDTO implements Serializable{

	private static final long serialVersionUID = 1L;
	
	@Key(AutoGenerated=true)
	@Field(MapTo = "ID") 
	private Long id;
	
	@Field(MapTo = "AVALUE")
    private String codeName;

	@Field(MapTo = "NVALUE")
    private Long codeKey;
		
	@Field(MapTo = "AUDITIME")
	@AuditField(Type=AuditFieldType.TIMESTAMP)
	@TemporalType(Type=TemporalTypes.TIMESTAMP)
    private String auditTime;

	... include getters/setter ...

}

	 * 
	 * Create a DTO Class in your EJBClient project
	 * 
	 * 
public class table1DTO  extends SharedDTO implements Serializable{

	private static final long serialVersionUID = 1L;
	
	private Long id;
    private String codeName;
    private Long codeKey;

	... include getters/setter ...

}
	 *
	 *  Create your EJBInterface in the EJBClient
	 *  
@Remote
public interface table1ServiceRemote extends SharedInterface<table1DTO>{

       //NOTHING

}
	 *  
	 *  Create your EJBService in the EJBproject
	 *  
@Stateless(name = "table1ServiceRemote")
@TransactionManagement(TransactionManagementType.CONTAINER)
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
@DeclareRoles( { "ProjectAdmin" })
public class table1ServiceBean extends SharedBean<table1DTO, table1DBDTO> implements table1ServiceRemote{

       //NOTHING

}
	 * 
	 * Now you can do FULL CRUD actions on that table
	 * 
	 * These default functions are available
	 * - These will return with a boolean success field set
	 * 
	 * public List<A> find(A dto);
	 * public A add(A dto);
	 * public A update(A dto);
	 * public A delete(A dto);
 	 *
 	 * - These will return with exception if something fails
 	 * 
 	 * public List<A> findE(A dto) throws DAOClientException;
	 * public A getE(A dto) throws DAOClientException;
	 * public A addE(A dto) throws DAOClientException;
	 * public A updateE(A dto) throws DAOClientException;
	 * public A deleteE(A dto) throws DAOClientException;
	 * 
	 * - You can override these as you see fit, especially to add security.
	 * - And add others that use the NamedQuery Option
	 * e.g: add extended method to interface then add metod to EJB
	 * 
@Remote
public interface table1ServiceRemote extends SharedInterface<table1DTO>{
    List<table1DTO> callQuery(table1DTO dto);
    Integer callQueryCount(table1DTO dto);
}

@Stateless(name = "table1ServiceRemote")
@TransactionManagement(TransactionManagementType.CONTAINER)
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
@DeclareRoles( { "ProjectAdmin" })
public class table1ServiceBean extends SharedBean<table1DTO, table1DBDTO> implements table1ServiceRemote{

	private static Logger logger = Logger.getLogger(table1ServiceBean.class.getName());

	@Override
	@RolesAllowed( { "ProjectAdmin" })
	@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
	public table1DTO add(table1DTO dto) {
		if (dto.getAuditUser() == null)
			dto.setAuditUser("AUDUSR");
		return super.add(dto);
	}

	@Override
	@RolesAllowed( { "ProjectAdmin" })
	@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
	public table1DTO addE(table1DTO dto) throws NotJPAClientException {
		if (dto.getAuditUser() == null)
			dto.setAuditUser("AUDUSR");
		return super.addE(dto);
	}
	
	
	public List<table1DTO> callQuery(table1DTO dto){
		List<table1DTO> DTOs = new ArrayList<table1DTO>();
		try {
			HashMap<String,String> parameters = new HashMap<String,String>();
			
			Query query = Manager.getNamedQuery("query1");

			parameters.put("AV1",dto.getCodeName());
			parameters.put("NV1",dto.getCodeKey());

			List<table1DTO> DBDTOs =  daoManager.findAll(query,parameters) ; 
			
			for (table1DBDTO DBDTO : DBDTOs){
				if(DBDTO.getId() != null){
					dto = new table1DTO(); 
					BeanUtils.getInstance().copyProperties(dto, DBDTO);
					dto.setSuccess(true);
					DTOs.add(dto);
				}
			}
			
		} catch (Exception e) {
			logger.error(e.getLocalizedMessage(), e);
			throw new NotJPAClientException(e.getLocalizedMessage(),e);
		}
		return DTOs;
	}
	
	public Integer callQueryCount(table1DTO dto){
		List<table1DTO> DTOs = new ArrayList<table1DTO>();
		try {
			HashMap<String,String> parameters = new HashMap<String,String>();
			
			Query query = Manager.getNamedQuery("query1");

			parameters.put("AV1",dto.getCodeName());
			parameters.put("NV1",dto.getCodeKey());

			ResultSet rs =  Manager.getResultSet(query,parameters) ;
			if (rs != null && rs.next()) {
				return rs.getInt("CNT");
			} else {
				throw new NotJPAClientException("Failed to execute Query");
			}
			
		} catch (Exception e) {
			logger.error(e.getLocalizedMessage(), e);
			throw new NotJPAClientException(e.getLocalizedMessage(),e);
		}
		return DTOs;
	}
	

}
	 * 
	 * 
	 * To USe this Framwork
	 * 
	 * 
public class testClass{

   public test(){
      table1ServiceRemote remote = table1EJBlookup.getInstance();

      table1DTO dto1 = new table1DTO();
      
      dto1.setCodeName("JANNIE");
      dto1.setCodeKey(001);
      
      dto1 = remote.add(dto1); //GEnerated ID should now be populated
	  
	  dto1 = new table1DTO();
      
      dto1.setCodeName("JANNIE");
      dto1.setCodeKey(002);
      
      dto1 = remote.add(dto1); //GEnerated ID should now be populated
      
      table1DTO dto2 = new table1DTO();
      dto2.setCodeName("JANNIE");

      List<table1DTO> dto2s = remote.find(dto2) //should return both records
      
      dto2 = new table1DTO();
      dto2.setId(dto1.getId());
      
      dto2 = remote.get(dto2); //should return the record based on the ID
      
   }

}
	 *
	 * 
	 */
	
	
}
